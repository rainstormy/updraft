import k from"fast-glob";import{readFile as C,writeFile as x}from"node:fs/promises";import{argv as P}from"node:process";async function S(e){const{severity:n,message:r}=e;switch(n){case"error":console.error(`ERROR: ${r}`);break;case"info":console.log(r);break;case"warning":console.warn(`WARNING: ${r}`);break}}async function M(e){const{filePatterns:n}=e;return await k.glob([...n],{dot:!0})}function g(e){if(!(e instanceof Error))throw e}async function O(e){const{paths:n}=e;return Promise.all(n.map(async r=>{try{const s=await C(r,"utf-8");return[r,s]}catch(s){g(s),V({path:r,errorMessage:s.message})}}))}function V(e){const{path:n,errorMessage:r}=e;throw new Error(`Failed to read ${n}: ${r}.`)}async function I(e){const{outputPathsWithContent:n}=e;await Promise.all(n.map(async([r,s])=>{try{await x(r,s,"utf-8")}catch(t){g(t),W({path:r,errorMessage:t.message})}}))}function W(e){const{path:n,errorMessage:r}=e;throw new Error(`Failed to write changes to ${n}: ${r}.`)}const j=/^(?<major>\d+)\.(?<minor>\d+)\.(?<patch>\d+)(?<prerelease>-[-\w]+(\.[-\w]+)*)?(?<build>\+[-\w]+(\.[-\w]+)*)?$/;function D(e){return j.test(e)}const T="1.0.0-alpha.0";function A(e){var f;const n={"--files":null,"--help":null,"--release-version":null,"--version":null};let r=null;for(const l of e){if(L(l)){if(n[l]!==null)return u({message:`${l} must be specified only once.`});r=l,n[r]=[];continue}if(l.startsWith("-"))return u({message:`Unknown option '${l}'.`});r!==null&&((f=n[r])==null||f.push(l))}if(e.length===0||n["--help"]!==null)return N();if(n["--version"]!==null)return z();const s=n["--release-version"];if(s===null)return u({message:"--release-version must be specified."});if(s.length===0)return u({message:"--release-version must specify a value."});if(s.length>1)return u({message:"--release-version must not specify more than one value."});const t=s[0],i=t.startsWith("v")?t.slice(1):t;if(!D(i))return u({message:`--release-version has an invalid value '${t}'.`});const a=n["--files"];return a===null?u({message:"--files must be specified."}):a.length===0?u({message:"--files must specify a value."}):H({files:a,releaseVersion:i})}const B=["--files","--help","--release-version","--version"];function L(e){return B.includes(e)}function N(){return{type:"help-screen"}}function u(e){const{message:n}=e;return{type:"invalid",errorMessage:n}}function H(e){const{files:n,releaseVersion:r}=e;return{type:"release",filePatterns:n,releaseVersion:r}}function z(){return{type:"tool-version"}}function G(e){const[n,...r]=e.split(/(?=^== .+)/mu);return{preamble:n.trim(),sections:q(r.map(J))}}function J(e){const[n,r]=K(e);return{repositoryUrl:Q(n),previousRelease:null,release:X(n)??null,sectionBody:r}}function K(e){const n=e.indexOf(`
`);return n>=0?[e.substring(3,n).trim(),e.substring(n+1).trim()]:[e.substring(3).trim(),""]}function q(e){return e.map((n,r)=>{var s;return{...n,previousRelease:((s=e[r+1])==null?void 0:s.release)??null}})}function Q(e){if(!e.includes("https://")&&!e.includes("{")&&!e.includes("}"))return null;if(e.includes("/compare/"))return e.substring(0,e.indexOf("/compare/"));if(e.includes("/releases/tag/"))return e.substring(0,e.indexOf("/releases/tag/"));const n=e.indexOf("[");return n>=0?e.substring(0,n):e}function X(e){if(!e.includes("/compare/")&&!e.includes("/releases/tag/"))return null;const n=e.indexOf("["),r=e.indexOf("] - ",n);return n===-1||r===-1?null:{version:e.substring(n+1,r),date:e.substring(r+4)}}function Y(e){return e.preamble+e.sections.map(n=>`


`+Z(n)+_(n)).join("")}function Z(e){return e.repositoryUrl===null?e.release===null?"== Unreleased":`== ${e.release.version} - ${e.release.date}`:e.release===null?`== ${e.repositoryUrl}${e.previousRelease===null?"":`/compare/v${e.previousRelease.version}\\...HEAD`}[Unreleased]`:`== ${e.repositoryUrl}${e.previousRelease===null?`/releases/tag/v${e.release.version}`:`/compare/v${e.previousRelease.version}\\...v${e.release.version}`}[${e.release.version}] - ${e.release.date}`}function _(e){return e.sectionBody!==""?`

`+e.sectionBody:""}async function ee(e){var i;const{originalChangelog:n,newRelease:r}=e,s=n.sections.find(a=>a.release===null)??null;if(s===null)throw new Error("must have an 'Unreleased' section");if(s.repositoryUrl===null)throw new Error("must have a link to the GitHub repository in the 'Unreleased' section");if(s.sectionBody==="")throw new Error("must have at least one item in the 'Unreleased' section");const t=n.sections.filter(a=>a.release!==null);return{...n,sections:[{repositoryUrl:s.repositoryUrl,previousRelease:r,release:null,sectionBody:""},{repositoryUrl:s.repositoryUrl,previousRelease:((i=t[0])==null?void 0:i.release)??null,release:r,sectionBody:s.sectionBody},...t]}}const v=/"version":\s*"(?<semanticVersionNumber>[^"]+)"/u;async function ne(e){const{originalPackageContent:n,newRelease:r}=e;if(!v.test(n))throw new Error("must have a 'version' field");return n.replace(v,`"version": "${r.version}"`)}function re(e){return e.status==="fulfilled"}function se(e){return e.status==="rejected"}const te=`Usage: updraft [options]

This tool prepares a repository for an upcoming release by updating changelogs
and bumping version numbers in package.json files.

Supported file formats:
  * AsciiDoc-based changelogs (*.adoc) in Keep a Changelog format.
  * package.json.

Options:
  --files <patterns>           Update files matching the glob patterns.
                               Mandatory when --release-version is specified.

                               Use whitespace to separate multiple patterns:
                               <pattern-1> <pattern-2> <pattern-3>

  --help                       Display this help screen and exit.

  --release-version <version>  The semantic version of the upcoming release.
                               Mandatory when --files is specified.

                               Expected format (optional parts in brackets):
                               [v]major.minor.patch[-prerelease][+buildinfo]

  --version                    Display the version of this tool and exit.`,oe=`
For usage instructions, please run the program with the --help option.`;async function ie(e,n){const{configuration:r,today:s,toolVersion:t}=e,{onDisplayingMessage:i,onListingMatchingFiles:a,onReadingFiles:f,onWritingToFiles:l}=n;switch(r.type){case"help-screen":return await h({message:te});case"invalid":return await F({message:r.errorMessage+oe});case"tool-version":return await h({message:t})}const{filePatterns:d,releaseVersion:b}=r,R={version:b,date:s};try{const o=await a({filePatterns:d});if(o.length===0)return await $({message:`${d.join(", ")} did not match any files.`});const c=await f({paths:o}),m=await Promise.allSettled(c.map(async([p,U])=>[p,await ae({path:p,originalContent:U,newRelease:R})])),w=m.filter(se).map(({reason:p})=>(g(p),p.message));if(w.length>0)return await y({messages:w});const E=m.filter(re).map(({value:p})=>p);return await l({outputPathsWithContent:E}),0}catch(o){return g(o),await y({messages:[o.message]})}async function h(o){const{message:c}=o;return await i({severity:"info",message:c}),0}async function $(o){const{message:c}=o;return await i({severity:"warning",message:c}),0}async function y(o){const{messages:c}=o;for(const m of c)await i({severity:"error",message:m});return 1}async function F(o){const{message:c}=o;return await i({severity:"error",message:c}),2}}async function ae(e){const{path:n,originalContent:r,newRelease:s}=e;switch(le({path:n})){case"changelog-asciidoc":return ce({path:n,originalContent:r,newRelease:s});case"node-package-json":return ue({path:n,originalContent:r,newRelease:s})}}function le(e){const{path:n}=e,r=n.split("/").at(-1)??"";if(r==="package.json")return"node-package-json";if(r.endsWith(".adoc"))return"changelog-asciidoc";throw new Error(`${n} is not a supported file format.`)}async function ce(e){const{path:n,originalContent:r,newRelease:s}=e;try{const t=G(r),i=await ee({originalChangelog:t,newRelease:s});return Y(i)}catch(t){throw g(t),new Error(`${n} ${t.message}.`)}}async function ue(e){const{path:n,originalContent:r,newRelease:s}=e;try{return await ne({originalPackageContent:r,newRelease:s})}catch(t){throw g(t),new Error(`${n} ${t.message}.`)}}const pe=new Date().toISOString().slice(0,10),ge=T;ie({configuration:A(P.slice(2)),today:pe,toolVersion:ge},{onDisplayingMessage:S,onListingMatchingFiles:M,onReadingFiles:O,onWritingToFiles:I}).catch(e=>{console.error(e)});
